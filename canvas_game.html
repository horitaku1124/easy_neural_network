<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Game</title>
<script>
class _DBSCANClustering {
    // TODO field declaration are not fully supported
    // inputValues = [];
    // minNumElements = 2;
    // epsilon = 1.0;
    // visitedPoints = new Set(); // should be Set
    // metric = (a, b) => 0;

    constructor(inputValues, minNumElements, epsilon, metric) {
        this.inputValues = inputValues;
        this.minNumElements = minNumElements;
        this.epsilon = epsilon;
        this.metric = metric;
        this.visitedPoints = new Set();
    }

    getNeighbours(jsonValue) {
        let verifyValue2 = JSON.parse(jsonValue);
        let neighbours = [];
        for (let candidate of this.inputValues) {
            if (this.metric(verifyValue2, candidate) <= this.epsilon) {
                neighbours.push(JSON.stringify(candidate));
            }
        }
        return neighbours;
    }

    static mergeRightToLeftCollection(neighbours1, neighbours2) {
        for (let tempPt of neighbours2) {
            if (!neighbours1.includes(tempPt)) {
                neighbours1.push(tempPt);
            }
        }
        return neighbours1;
    }

    performClustering() {
        let resultList = [];
        this.visitedPoints.clear();

        let neighbours = [];
        let index = 0;
        while (this.inputValues.length > index) {
            let p = this.inputValues[index];
            let inputValue = JSON.stringify(p);
            if (!this.visitedPoints.has(inputValue)) {
                this.visitedPoints.add(inputValue);
                let neighbours = this.getNeighbours(inputValue);

                if (neighbours.length >= this.minNumElements) {
                    let ind = 0;
                    while (neighbours.length > ind) {
                        let jsonNeighbour = neighbours[ind];
                        // let jsonNeighbour = JSON.stringify(r);
                        if (!this.visitedPoints.has(jsonNeighbour)) {
                            this.visitedPoints.add(jsonNeighbour);
                            let individualNeighbours = this.getNeighbours(jsonNeighbour);
                            if (individualNeighbours.length >= this.minNumElements) {
                                neighbours = DBSCANClustering.mergeRightToLeftCollection(
                                    neighbours, individualNeighbours)
                            }
                        }
                        ind++
                    }
                    resultList.push(neighbours)
                }
            }
            index++
        }
        for (let i = 0;i < resultList.length;i++) {
            let cluster = resultList[i];
            for (let j = 0;j < cluster.length;j++) {
                cluster[j] = JSON.parse(cluster[j]);
            }
            resultList[i] = cluster;
        }

        return resultList;
    }
}

const metric = (v1, v2) => {
    return Math.sqrt(Math.pow(v1[0] - v2[0], 2) + Math.pow(v1[1] - v2[1], 2));
}
</script>
<script>
let mainDisplay;
let debugDisplay;
let worker = new Worker('doWork.js');
let ctx;
let ctx2;
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOMContentLoaded", performance.now());
    mainDisplay = document.getElementById('main_display');
    debugDisplay = document.getElementById('debug_display');
    if (!mainDisplay || !mainDisplay.getContext) {
        throw Error('Context');
    }
    ctx = mainDisplay.getContext('2d');
    ctx2 = debugDisplay.getContext('2d');

    let stoneImg = new Image();
    stoneImg.src = "irasutoya/ishi_stone.png";
    let allResourcesAreLoaded = false;
    stoneImg.onload = () => {
        allResourcesAreLoaded = true;
    };

    let detectedObjects = [];
    worker.addEventListener('message', function(e) {
        console.log("worker finished", performance.now() - startedAt, e.data);
        detectedObjects = e.data
        detectStart();
    }, false);

    let stoneX = mainDisplay.width;
    let animationFrame = function(timestamp) {
        if (allResourcesAreLoaded) {
            ctx.fillStyle = "#FFF";
            ctx.fillRect(0, 0, mainDisplay.width, mainDisplay.height);
            // ctx.stroke();
            ctx.drawImage(stoneImg, 0, 0, stoneImg.width, stoneImg.height, stoneX, 50, stoneImg.width / 3, stoneImg.height / 3);

            ctx.stroke();
            stoneX--;
            if (stoneX + stoneImg.width < 0) {
                stoneX = mainDisplay.width;
            }

            let imageData = ctx.getImageData(0, 0, mainDisplay.width, mainDisplay.height);
            ctx2.putImageData(imageData, 0, 0);

            window.requestAnimationFrame(animationFrame);
            imageData = ctx2.getImageData(0, 0, mainDisplay.width, mainDisplay.height);
            imageDataUint = new Uint8ClampedArray(imageData.data);

            for (let [minX, minY, maxX, maxY] of detectedObjects) {
                ctx2.beginPath();
                ctx2.strokeStyle = "red";
                ctx2.rect(minX, minY, maxX - minX, maxY - minY);
                ctx2.stroke();
            }
        }
    };
    window.requestAnimationFrame(animationFrame);
    detectStart();
});


let imageDataUint;
let startedAt;
function detectStart() {
    if (imageDataUint && imageDataUint.length > 0) {
        worker.postMessage({
            "imageData": imageDataUint,
            "width": mainDisplay.width,
            "height": mainDisplay.height,
        });
        startedAt = performance.now();
    } else {
        setTimeout(detectStart, 100);
    }
}
</script>
<style>
    canvas {
        border: 1px solid #aaa;
    }
</style>
</head>
<body>
<canvas id="main_display" width="600" height="300"></canvas><br><br>
<canvas id="debug_display" width="600" height="300"></canvas>
</body>
</html>